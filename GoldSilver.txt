//
// Copyright (C) 2021, NinjaTrader LLC <www.ninjatrader.com>.
// NinjaTrader reserves the right to modify or overwrite this NinjaScript component with each release.
//
#region Using declarations
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.ComponentModel.DataAnnotations;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Input;
using System.Windows.Media;
using System.Xml.Serialization;
using NinjaTrader.Cbi;
using NinjaTrader.Gui;
using NinjaTrader.Gui.Chart;
using NinjaTrader.Gui.SuperDom;
using NinjaTrader.Data;
using NinjaTrader.NinjaScript;
using NinjaTrader.Core.FloatingPoint;
using NinjaTrader.NinjaScript.Indicators;
using NinjaTrader.NinjaScript.DrawingTools;
//using NinjaTrader.NinjaScript.Indicators.TDU;

using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.ComponentModel.DataAnnotations;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Input;
using System.Windows.Media;
using System.Xml.Serialization;
using NinjaTrader.Cbi;
using NinjaTrader.Gui;
using NinjaTrader.Gui.Chart;
using NinjaTrader.Gui.SuperDom;
using NinjaTrader.Gui.Tools;
using NinjaTrader.Data;
using NinjaTrader.NinjaScript;
using NinjaTrader.Core.FloatingPoint;
using NinjaTrader.NinjaScript.DrawingTools;

#endregion

/*
ES : TP 4, extra 1
YM : TP 10, extra 2
NQ : TP 7, extra 2
RTY: TP 4, extra 8
*/
namespace NinjaTrader.NinjaScript.Strategies
{
    public class KellyGoldSilverStrategy : Strategy
    {
//		private TrendMagic TrendMagic1;
		
		private Series<double> barHigh;
		private Series<double> barLow;
		private Series<double> barClose;
		
//		private NinjaTrader.NinjaScript.Indicators.KellyAnn.Nearest4Levels Nearest4Levels1;

		private string  atmStrategyId			= string.Empty;
		private string  orderId					= string.Empty;
		private bool	isAtmStrategyCreated	= false;
		
//        private TDUSupportResistance _sr;
        private int _lastBar = 0;
		private double _lastLevel;
        private double _lastLevel1;
		private double _lastLevel2;
		private double _lastLevel3;
		private double _lastLevel4;
		private double _lastLevel5;
		private double _lastLevel6;
		private double _lastLevel7;
		private double _lastLevel8;
		
		// Time-based tracking variables
		private DateTime _levelCBreachTime = DateTime.MinValue;
		private DateTime _levelABreachTime = DateTime.MinValue;
		private bool _levelCBreached = false;
		private bool _levelABreached = false;
		private bool _levelBTradeExecuted = false;
		private bool _levelDTradeExecuted = false;
		private int _timeWindowMinutes = 20;
		
		private int		breakEvenTicks		= 4;//default 5, 6		// Default setting for ticks needed to acheive before stop moves to breakeven		
		private int		plusBreakEven		= 0; //default 3, 2		// Default setting for amount of ticks past breakeven to actually breakeven
		private int		profitTargetTicks	= 400;//default 200		// Default setting for how many Ticks away from AvgPrice is profit target
        private int		stopLossTicks		= 4;//default 8, 6		// Default setting for stoploss. Ticks away from AvgPrice (changed to 4 for trailing stop)		
		private int		trailProfitTrigger	= 5;//default 9	, 8	// 8 Default Setting for trail trigger ie the number of ticks movede after break even befor activating TrailStep
		private int		trailStepTicks		= 4;//default 3, 2		// 2 Default setting for number of ticks advanced in the trails - set to 4 for constant trailing
		private int 	BarTraded 			= 0; //default 0		// Default setting for Bar number that trade occurs	
		
		private bool	showLines			= false;		// Turn on/off the profit targett, stoploss and trailing stop plots  // new for NT8
		
		private double	initialBreakEven	= 0; 		// Default setting for where you set the breakeven
		private double 	previousPrice		= 0;		// previous price used to calculate trailing stop
		private double 	newPrice			= 0;		// Default setting for new price used to calculate trailing stop
		private double	stopPlot			= 0;		// Value used to plot the stop level

        protected override void OnStateChange()
        {
            if (State == State.SetDefaults)
            {
                Description = "KellyGoldSilverStrategy";
                Name = "KellyGoldSilverStrategy";
				
				AddPlot(new Stroke(Brushes.Transparent, 2), PlotStyle.Line, "InvisiblePlot");
				
                TakeProfit = 7;
                IsInstantiatedOnEachOptimizationIteration = false;
//                Calculate = Calculate.OnEachTick;
				Calculate = Calculate.OnPriceChange;
//				Calculate = Calculate.OnBarClose;
                ExtraSLTicks = 2;
                ExtraRetracementTicks = 2;
//                MinTouches = 0;
                IncludeCommission = true;
                RealtimeErrorHandling = RealtimeErrorHandling.IgnoreAllErrors;
                IsExitOnSessionCloseStrategy = false;
				
//				IsSuspendedWhileInactive = false;
//                PaintPriceMarkers = false;
                DisplayInDataBox = false;
                DrawOnPricePanel = true;
                BarsRequiredToPlot = 4;
                IsAutoScale = false;
                IsOverlay = true;
				
//                AddPlot(new Stroke(Brushes.Transparent, 2), PlotStyle.Line, "InvisiblePlot");
				
                LevelA = 0;
                LevelB = 26;
                LevelC = 50;
                LevelD = 77;
				
				LevelALine = new Stroke(Brushes.Blue);
				LevelBLine = new Stroke(Brushes.Green);
				LevelCLine = new Stroke(Brushes.Red);
				LevelDLine = new Stroke(Brushes.Purple);
				
				

            }
            else if (State == State.Configure)
            {
//                AddDataSeries(BarsPeriodType.Tick, 1);
				
				barHigh = new Series<double>(this);
				barLow = new Series<double>(this);
				barClose = new Series<double>(this);
				
				SetStopLoss(CalculationMode.Ticks, stopLossTicks);
				SetProfitTarget(CalculationMode.Ticks, profitTargetTicks);	
            }
            else if (State == State.DataLoaded)
            {
//				TrendMagic1				= TrendMagic(Close, 20, 14, 1, false);
//				TrendMagic1.Plots[0].Brush = Brushes.Orange;
//				TrendMagic1.Plots[1].Brush = Brushes.Transparent;
//				TrendMagic1.Plots[2].Brush = Brushes.Transparent;
//				AddChartIndicator(TrendMagic1);
				
//                _sr = TDUSupportResistance(Close, TDUSRZoneType.Line,10,16,16,50,15,15,TDUZoneBreakType.CandleClosesOutsideZone,false,BarsPeriodType.Minute,5,1000,"jonesy3@gmail.com",6381183434951);
//                _sr.ShowBrokenLines = false;
//                _sr.ShowBroken = false;
//				_sr.ShowPreviousTouches= false;
//				_sr.ShowPrice= false;
//				_sr.ShowPreviousTouchesCount=false;

//                AddChartIndicator(_sr);
				
//				Nearest4Levels1				= Nearest4Levels(Close, 0, 26, 50, 77, NinjaTrader.Gui.Stroke, NinjaTrader.Gui.Stroke, NinjaTrader.Gui.Stroke, NinjaTrader.Gui.Stroke);
//				Nearest4Levels1.Plots[0].Brush = Brushes.Transparent;
//				AddChartIndicator(Nearest4Levels1);
            }
        }

        protected override void OnBarUpdate()
        {
            if (BarsInProgress != 0) return;
            if (CurrentBar < BarsRequiredToTrade)
                return;
            if (_lastBar == CurrentBar) return;
			// Make sure this strategy does not execute against historical data
			if(State == State.Historical)
				return;
			
			barHigh[0] = High[0];
			barLow[0] = Low[0];
			barClose[0] = Low[0];
			
			#region Calculate
            double price = Close[0];
            double priceInt = Math.Floor(Math.Floor(price)/100);

//            levelAValue = (priceInt + (LevelA / 100.0)) * 100;
//            levelBValue = (priceInt + (LevelB / 100.0)) * 100;
//            levelCValue = (priceInt + (LevelC / 100.0)) * 100;
//            levelDValue = (priceInt + (LevelD / 100.0)) * 100;
			
			double LevelAValue = (priceInt + (LevelA / 100.0)) * 100;
            double LevelBValue = (priceInt + (LevelB / 100.0)) * 100;
            double LevelCValue = (priceInt + (LevelC / 100.0)) * 100;
            double LevelDValue = (priceInt + (LevelD / 100.0)) * 100;
			
//			levelCValue2[0] = (priceInt + (LevelC / 100.0)) * 100;
			
//			double LevelAValue = (priceInt + (LevelA / 100.0)) * 100;
//            double LevelBValue = (priceInt + (LevelB / 100.0)) * 100;
//            double LevelCValue = (priceInt + (LevelC / 100.0)) * 100;
//            double LevelDValue = (priceInt + (LevelD / 100.0)) * 100;

            if (price < LevelAValue)
            {
                LevelAValue -= 1.0;
                LevelBValue -= 1.0;
                LevelCValue -= 1.0;
                LevelDValue -= 1.0;
				
//				levelCValue2[0] -= 1.0;
            }
			#endregion
			
			// Time-based trading logic
			DateTime currentTime = Time[0];
			
			// Check for LevelC breach (price drops below LevelC)
			if (!_levelCBreached && Close[0] < LevelCValue)
			{
				_levelCBreached = true;
				_levelCBreachTime = currentTime;
				_levelBTradeExecuted = false; // Reset trade flag when new breach occurs
				Print($"Price dropped below LevelC ({LevelCValue}) at {currentTime}. Starting 20-minute window for LevelB trade.");
			}
			
			// Check for LevelA breach (price goes above LevelA)
			if (!_levelABreached && Close[0] > LevelAValue)
			{
				_levelABreached = true;
				_levelABreachTime = currentTime;
				_levelDTradeExecuted = false; // Reset trade flag when new breach occurs
				Print($"Price went above LevelA ({LevelAValue}) at {currentTime}. Starting 20-minute window for LevelD trade.");
			}
			
			// Reset breach flags if price moves back
			if (_levelCBreached && Close[0] >= LevelCValue)
			{
				_levelCBreached = false;
				Print($"Price moved back above LevelC ({LevelCValue}). Resetting LevelC breach flag.");
			}
			
			if (_levelABreached && Close[0] <= LevelAValue)
			{
				_levelABreached = false;
				Print($"Price moved back below LevelA ({LevelAValue}). Resetting LevelA breach flag.");
			}
			
			#region Plot
            Draw.HorizontalLine(this, "LevelA"+LevelAValue, LevelAValue, LevelALine.Brush, LevelALine.DashStyleHelper
				, (int) LevelALine.Width);
            Draw.HorizontalLine(this, "LevelB"+LevelBValue, LevelBValue, LevelBLine.Brush, LevelBLine.DashStyleHelper
				, (int) LevelBLine.Width);
            Draw.HorizontalLine(this, "LevelC"+LevelCValue, LevelCValue, LevelCLine.Brush, LevelCLine.DashStyleHelper
				, (int) LevelCLine.Width);
            Draw.HorizontalLine(this, "LevelD"+LevelDValue, LevelDValue, LevelDLine.Brush, LevelDLine.DashStyleHelper
				, (int) LevelDLine.Width);
			#endregion
			
			// Modified trailing stop logic - 4 ticks behind price at all times
			switch (Position.MarketPosition)
            {
                case MarketPosition.Flat:
                    SetStopLoss(CalculationMode.Ticks, 4); // Always 4 ticks
					previousPrice = 0;
					stopPlot = 0;
                    break;
					   
                case MarketPosition.Long:
					// Trailing stop - always 4 ticks behind current price
					double trailingStopPrice = Close[0] - 4 * TickSize;
					SetStopLoss(CalculationMode.Price, trailingStopPrice);
					stopPlot = trailingStopPrice;
					
					if (showLines)
					{
						ProfitTarget[0] = Position.AveragePrice + profitTargetTicks * TickSize;
						StopLoss[0] = stopPlot;
					}
                    break;
					
                case MarketPosition.Short:
					// Trailing stop - always 4 ticks above current price
					double trailingStopPriceShort = Close[0] + 4 * TickSize;
					SetStopLoss(CalculationMode.Price, trailingStopPriceShort);
					stopPlot = trailingStopPriceShort;
					
					if (showLines)
					{
						ProfitTarget[0] = Position.AveragePrice - profitTargetTicks * TickSize;
						StopLoss[0] = stopPlot;
					}
                    break;
                default:
                    break;
			}	
			
//			Print("levelAValue Onbarupdate: " + Nearest4Levels(Close, 0, 26, 50, 77, new NinjaTrader.Gui.Stroke(Brushes.Green, DashStyleHelper.Dash, 2), new NinjaTrader.Gui.Stroke(Brushes.Green, DashStyleHelper.Dash, 2), new NinjaTrader.Gui.Stroke(Brushes.Green, DashStyleHelper.Dash, 2), new NinjaTrader.Gui.Stroke(Brushes.Green, DashStyleHelper.Dash, 2)).LevelAValue);
//			Print("levelBValue Onbarupdate: " + Nearest4Levels(Close, 0, 26, 50, 77, new NinjaTrader.Gui.Stroke(Brushes.Green, DashStyleHelper.Dash, 2), new NinjaTrader.Gui.Stroke(Brushes.Green, DashStyleHelper.Dash, 2), new NinjaTrader.Gui.Stroke(Brushes.Green, DashStyleHelper.Dash, 2), new NinjaTrader.Gui.Stroke(Brushes.Green, DashStyleHelper.Dash, 2)).LevelBValue);
//			Print("levelCValue Onbarupdate: " + Nearest4Levels(Close, 0, 26, 50, 77, new NinjaTrader.Gui.Stroke(Brushes.Green, DashStyleHelper.Dash, 2), new NinjaTrader.Gui.Stroke(Brushes.Green, DashStyleHelper.Dash, 2), new NinjaTrader.Gui.Stroke(Brushes.Green, DashStyleHelper.Dash, 2), new NinjaTrader.Gui.Stroke(Brushes.Green, DashStyleHelper.Dash, 2)).LevelCValue);
//			Print("levelDValue Onbarupdate: " + Nearest4Levels(Close, 0, 26, 50, 77, new NinjaTrader.Gui.Stroke(Brushes.Green, DashStyleHelper.Dash, 2), new NinjaTrader.Gui.Stroke(Brushes.Green, DashStyleHelper.Dash, 2), new NinjaTrader.Gui.Stroke(Brushes.Green, DashStyleHelper.Dash, 2), new NinjaTrader.Gui.Stroke(Brushes.Green, DashStyleHelper.Dash, 2)).LevelDValue);
		
//			Print("levelCValue2 Onbarupdate: " + Nearest4Levels(Close, 0, 26, 50, 77, new NinjaTrader.Gui.Stroke(Brushes.Green, DashStyleHelper.Dash, 2), new NinjaTrader.Gui.Stroke(Brushes.Green, DashStyleHelper.Dash, 2), new NinjaTrader.Gui.Stroke(Brushes.Green, DashStyleHelper.Dash, 2), new NinjaTrader.Gui.Stroke(Brushes.Green, DashStyleHelper.Dash, 2)).LevelCValue2[0]);

//			if (CrossAbove(Nearest4Levels1, Nearest4Levels1, 1))
			
            if (Position.MarketPosition == MarketPosition.Flat)
            {
				
				// BUY ORDER: Price reaches LevelB after dropping below LevelC within 20 minutes
				if (_levelCBreached && 
					!_levelBTradeExecuted && 
					Close[0] >= LevelBValue && 
					(currentTime - _levelCBreachTime).TotalMinutes <= _timeWindowMinutes)
				{
					_lastBar = CurrentBar;
					_levelBTradeExecuted = true;
					EnterLong(1, "BuyAtLevelB");
					
					double minutesElapsed = (currentTime - _levelCBreachTime).TotalMinutes;
					Print($"BUY ORDER EXECUTED: Price reached LevelB ({LevelBValue}) at {currentTime}");
					Print($"Time elapsed since LevelC breach: {minutesElapsed:F2} minutes");
					Print($"Current Price: {Close[0]}, LevelB: {LevelBValue}, LevelC: {LevelCValue}");
					return;
				}
				
				// SELL ORDER: Price reaches LevelD after going above LevelA within 20 minutes
				if (_levelABreached && 
					!_levelDTradeExecuted && 
					Close[0] <= LevelDValue && 
					(currentTime - _levelABreachTime).TotalMinutes <= _timeWindowMinutes)
				{
					_lastBar = CurrentBar;
					_levelDTradeExecuted = true;
					EnterShort(1, "SellAtLevelD");
					
					double minutesElapsed = (currentTime - _levelABreachTime).TotalMinutes;
					Print($"SELL ORDER EXECUTED: Price reached LevelD ({LevelDValue}) at {currentTime}");
					Print($"Time elapsed since LevelA breach: {minutesElapsed:F2} minutes");
					Print($"Current Price: {Close[0]}, LevelD: {LevelDValue}, LevelA: {LevelAValue}");
					return;
				}
				
				// Reset time windows if expired
				if (_levelCBreached && (currentTime - _levelCBreachTime).TotalMinutes > _timeWindowMinutes)
				{
					_levelCBreached = false;
					_levelBTradeExecuted = false;
					Print($"LevelC breach time window expired. Resetting flags.");
				}
				
				if (_levelABreached && (currentTime - _levelABreachTime).TotalMinutes > _timeWindowMinutes)
				{
					_levelABreached = false;
					_levelDTradeExecuted = false;
					Print($"LevelA breach time window expired. Resetting flags.");
				}
            	}
			
        	}
		
//		bool checktime(int now)
//		{
//			if((FromTime<=ToTime) && (now>=FromTime && now<ToTime))     return true;
	    	    
//			if((FromTime>ToTime) && (now>=FromTime || now<ToTime))	return true;
        
//			return false;
//		}

        #region Properties
		
		[Browsable(false)]
		[XmlIgnore]		
        public Series<double>  BarHigh
        {
            get { return barHigh; }	// Allows our public BullIndication Series<bool> to access and expose our interal bullIndication Series<bool>
        }
		[Browsable(false)]
		[XmlIgnore]		
        public Series<double>  BarLow
        {
            get { return barLow; }	// Allows our public BullIndication Series<bool> to access and expose our interal bullIndication Series<bool>
        }
		[Browsable(false)]
		[XmlIgnore]		
        public Series<double>  BarClose
        {
            get { return barClose; }	// Allows our public BullIndication Series<bool> to access and expose our interal bullIndication Series<bool>
        }
		
        [Range(1, int.MaxValue), NinjaScriptProperty]
        [Display(ResourceType = typeof(Custom.Resource), Name = "Take Profit (ticks)", GroupName = "01. Parameters", Order = 0)]
        public int TakeProfit { get; set; }

        [Range(0, int.MaxValue), NinjaScriptProperty]
        [Display(ResourceType = typeof(Custom.Resource), Name = "Extra SL (ticks)", GroupName = "01. Parameters", Order = 1)]
        public int ExtraSLTicks { get; set; }
		
        [Range(0, int.MaxValue), NinjaScriptProperty]
        [Display(ResourceType = typeof(Custom.Resource), Name = "Extra Retracement (ticks)", GroupName = "01. Parameters", Order = 2)]
        public int ExtraRetracementTicks { get; set; }

//        [Range(0, int.MaxValue), NinjaScriptProperty]
//        [Display(ResourceType = typeof(Custom.Resource), Name = "Min. Touches", GroupName = "01. Parameters", Order = 3)]
//        public int MinTouches { get; set; }

		
 		[Range(0, int.MaxValue)]
		[NinjaScriptProperty]
		[Display(Name="Profit Target Ticks", Description="Number of ticks away from entry price for the Profit Target order", Order=1, GroupName="Parameters")]
		public int ProfitTargetTicks
		{
			get { return profitTargetTicks; }
			set { profitTargetTicks = value; }
		}

		[Range(0, int.MaxValue)]
		[NinjaScriptProperty]
		[Display(Name="Trailing Stop Ticks", Description="Numbers of ticks behind current price for trailing stop", Order=2, GroupName="Parameters")]
		public int StopLossTicks
		{
			get { return stopLossTicks; }
			set { stopLossTicks = value; }
		}
		
		[Range(1, int.MaxValue)]
		[NinjaScriptProperty]
		[Display(Name="Time Window Minutes", Description="Time window in minutes for level breach conditions", Order=3, GroupName="Parameters")]
		public int TimeWindowMinutes
		{
			get { return _timeWindowMinutes; }
			set { _timeWindowMinutes = value; }
		}

		[Range(0, int.MaxValue)]
		[NinjaScriptProperty]
		[Display(Name="BreakEven Ticks Trigger", Description="Number of ticks in Profit to trigger stop to move to Plus Breakeven ticks level", Order=4, GroupName="Parameters")]
		public int BreakEvenTicks
		{
			get {return breakEvenTicks;}
			set {breakEvenTicks = value;}
		}

		[Range(0, int.MaxValue)]
		[NinjaScriptProperty]
		[Display(Name="BreakEven Ticks level", Description="Number of ticks past breakeven for breakeven stop (can be zero)", Order=5, GroupName="Parameters")]
		public int PlusBreakEven
		{
			get { return plusBreakEven; }
			set { plusBreakEven = value; }
		}

		[Range(0, int.MaxValue)]
		[NinjaScriptProperty]
		[Display(Name="Trail Profit Trigger", Description="Number of ticks in profit to trigger trail stop action", Order=6, GroupName="Parameters")]
		public int TrailProfitTrigger
		{
			get {return trailProfitTrigger;}
			set {trailProfitTrigger = value;}
		}
		
		[Range(0, int.MaxValue)]
		[NinjaScriptProperty]
		[Display(Name="Trail Step Ticks", Description="Number of ticks to step for each adjustment of trail stop", Order=7, GroupName="Parameters")]
		public int TrailStepTicks
		{
			get {return trailStepTicks;}
			set {trailStepTicks = value;}
		}
		[NinjaScriptProperty]
		[Display(Name = "Show Lines", Description="Plot profit and stop lines on chart", Order = 8, GroupName = "Parameters")]
		public bool ShowLines
		{
			get { return showLines; } 
			set { showLines = value; }
		}		

		[Browsable(false)]
		[XmlIgnore]
		public Series<double> ProfitTarget
		{
			get { return Values[0]; }
		}

		[Browsable(false)]
		[XmlIgnore]
		public Series<double> StopLoss
		{
			get { return Values[1]; }
		}
		
		[Range(0, int.MaxValue), NinjaScriptProperty]
        [Display(Name = "Level A", Order = 1, GroupName = "Parameters")]
        public int LevelA { get; set; }

        [Range(0, int.MaxValue), NinjaScriptProperty]
        [Display(Name = "Level B", Order = 2, GroupName = "Parameters")]
        public int LevelB { get; set; }

        [Range(0, int.MaxValue), NinjaScriptProperty]
        [Display(Name = "Level C", Order = 3, GroupName = "Parameters")]
        public int LevelC { get; set; }

        [Range(0, int.MaxValue), NinjaScriptProperty]
        [Display(Name = "Level D", Order = 4, GroupName = "Parameters")]
        public int LevelD { get; set; }

		[NinjaScriptProperty]
		[Display(Name = "Level A Line", Order = 5, GroupName = "Parameters")]
		public Stroke LevelALine { get; set; }		

		[NinjaScriptProperty]
		[Display(Name = "Level B Line", Order = 6, GroupName = "Parameters")]
		public Stroke LevelBLine { get; set; }		

		[NinjaScriptProperty]
		[Display(Name = "Level C Line", Order = 7, GroupName = "Parameters")]
		public Stroke LevelCLine { get; set; }		

		[NinjaScriptProperty]
		[Display(Name = "Level D Line", Order = 8, GroupName = "Parameters")]
		public Stroke LevelDLine { get; set; }
        #endregion
    }
}


